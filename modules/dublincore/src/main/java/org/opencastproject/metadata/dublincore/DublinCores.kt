/**
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 *
 * The Apereo Foundation licenses this file to you under the Educational
 * Community License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License
 * at:
 *
 * http://opensource.org/licenses/ecl2.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package org.opencastproject.metadata.dublincore

import java.util.UUID.randomUUID
import javax.xml.XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI
import org.opencastproject.mediapackage.XMLCatalogImpl.Companion.XSI_NS_PREFIX
import org.opencastproject.metadata.dublincore.DublinCore.ELEMENTS_1_1_NS_PREFIX
import org.opencastproject.metadata.dublincore.DublinCore.ELEMENTS_1_1_NS_URI
import org.opencastproject.metadata.dublincore.DublinCore.TERMS_NS_PREFIX
import org.opencastproject.metadata.dublincore.DublinCore.TERMS_NS_URI

import org.opencastproject.mediapackage.EName
import org.opencastproject.mediapackage.MediaPackageElementFlavor
import org.opencastproject.mediapackage.MediaPackageElements
import org.opencastproject.metadata.dublincore.OpencastDctermsDublinCore.Episode
import org.opencastproject.metadata.dublincore.OpencastDctermsDublinCore.Series
import org.opencastproject.util.XmlNamespaceBinding
import org.opencastproject.util.XmlNamespaceContext

import com.entwinemedia.fn.data.Opt

import org.apache.commons.io.IOUtils

import java.io.IOException
import java.io.InputStream
import javax.annotation.ParametersAreNonnullByDefault
import javax.xml.XMLConstants

/**
 * Factory for metadata catalogs following the DublinCore standard.
 */
@ParametersAreNonnullByDefault
object DublinCores {
    /**
     * Namespace name of Dublin Core metadata generated by Opencast. By default this namespace is the default namespace
     * of xml documents generated by this class.
     */
    val OC_DC_CATALOG_NS_URI = "http://www.opencastproject.org/xsd/1.0/dublincore/"

    /** The dc root element of Opencast DublinCore catalogs.  */
    val OC_DC_CATALOG_ROOT_ELEMENT = EName(OC_DC_CATALOG_NS_URI, "dublincore")

    /** Namespace URI for Opencast properties.  */
    val OC_PROPERTY_NS_URI = "http://www.opencastproject.org/matterhorn/"

    /** Prefix for Opencast properties.  */
    val OC_PROPERTY_NS_PREFIX = "oc"

    /**
     * Opencast property: The timezone of the agent specified to be scheduled with an event. IE: "America/Chicago"
     */
    val OC_PROPERTY_AGENT_TIMEZONE = EName(OC_PROPERTY_NS_URI, "agentTimezone")

    /**
     * This is a string defining a recurrence pattern as specified in RFC 2445. See [http://tools.ietf.org/html/rfc2445#section-4.8.5.4](http://tools.ietf.org/html/rfc2445#section-4.8.5.4)
     */
    val OC_PROPERTY_RECURRENCE = EName(OC_PROPERTY_NS_URI, "recurrence")
    val OC_PROPERTY_ANNOTATION = EName(OC_PROPERTY_NS_URI, "annotation")
    val OC_PROPERTY_ADVERTISED = EName(OC_PROPERTY_NS_URI, "advertised")
    val OC_PROPERTY_PROMOTED = EName(OC_PROPERTY_NS_URI, "promoted")
    val OC_PROPERTY_DURATION = EName(OC_PROPERTY_NS_URI, "duration")

    /**
     * Create a new Opencast DublinCore metadata catalog for episodes.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.EPISODE].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier] and the
     * [identifier][DublinCore.PROPERTY_IDENTIFIER] property is not set.
     *
     *
     */
    @Deprecated("use {@link #mkOpencastEpisode()} instead")
    fun mkOpencast(): Episode {
        return mkOpencastEpisode()
    }

    /**
     * Create a new Opencast DublinCore metadata catalog for episodes.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.EPISODE].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier] and the
     * [identifier][DublinCore.PROPERTY_IDENTIFIER] property is not set.
     *
     */
    fun mkOpencastEpisode(): Episode {
        return Episode(mkOpencast(MediaPackageElements.EPISODE))
    }

    /**
     * Create a new Opencast DublinCore metadata catalog for episodes.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.EPISODE].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * Set the [dcterms:identifier][DublinCore.PROPERTY_IDENTIFIER] to `id`
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier]
     *
     */
    fun mkOpencastEpisode(id: String): Episode {
        val dc = mkOpencastEpisode()
        dc.setDcIdentifier(id)
        return dc
    }

    /**
     * Create a new Opencast DublinCore metadata catalog for episodes.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.EPISODE].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * Set the [dcterms:identifier][DublinCore.PROPERTY_IDENTIFIER] to `id` if some, or create a random
     * UUID otherwise
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier]
     *
     */
    fun mkOpencastEpisode(id: Opt<String>): Episode {
        val dc = mkOpencastEpisode()
        dc.setDcIdentifier(id.getOr(randomUUID().toString()))
        return dc
    }

    /**
     * Create a new Opencast DublinCore metadata catalog for episodes.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.EPISODE].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * Set the [dcterms:identifier][DublinCore.PROPERTY_IDENTIFIER] to `id`
     *  * Link to series `seriesId` setting the [DublinCore.PROPERTY_IS_PART_OF] property.
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier]
     *
     */
    fun mkOpencastEpisode(id: String, seriesId: String): Episode {
        val dc = mkOpencastEpisode(id)
        dc.setIsPartOf(seriesId)
        return dc
    }

    /**
     * Create an Opencast episode DublinCore accessor for a [DublinCoreCatalog].
     * Read and write operations access and modify the wrapped catalog.
     */
    fun mkOpencastEpisode(dc: DublinCoreCatalog): Episode {
        return Episode(dc)
    }

    /**
     * Create a new Opencast DublinCore metadata catalog for series.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.SERIES].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier] and the
     * [identifier][DublinCore.PROPERTY_IDENTIFIER] property is not set.
     *
     */
    fun mkOpencastSeries(): Series {
        return Series(mkOpencast(MediaPackageElements.SERIES))
    }

    /**
     * Create a new Opencast DublinCore metadata catalog for series.
     *
     *  * Set flavor to [org.opencastproject.mediapackage.MediaPackageElements.SERIES].
     *  * Register all necessary namespaces and set the root tag to [.OC_DC_CATALOG_ROOT_ELEMENT].
     *  * Set the [dcterms:identifier][DublinCore.PROPERTY_IDENTIFIER] to `id`
     *  * The catalog does not have an [identifier][DublinCoreCatalog.getIdentifier]
     *
     */
    fun mkOpencastSeries(id: String): Series {
        val dc = mkOpencastSeries()
        dc.setDcIdentifier(id)
        return dc
    }

    /**
     * Create an Opencast series DublinCore accessor for a [DublinCoreCatalog].
     * Read and write operations access and modify the wrapped catalog.
     */
    fun mkOpencastSeries(dc: DublinCoreCatalog): Series {
        return Series(dc)
    }

    /**
     * Create a new empty catalog suitable to take properties from the standard DublinCore
     * namespaces [DublinCore.ELEMENTS_1_1_NS_URI] and [DublinCore.TERMS_NS_URI].
     *
     *
     * Please note that neither a flavor nor a root tag is set.
     */
    fun mkStandard(): DublinCoreCatalog {
        val dc = DublinCoreCatalog()
        dc.addBindings(XmlNamespaceContext.mk(
                XmlNamespaceBinding.mk(ELEMENTS_1_1_NS_PREFIX, ELEMENTS_1_1_NS_URI),
                XmlNamespaceBinding.mk(TERMS_NS_PREFIX, TERMS_NS_URI)))
        return dc
    }

    /** Create a new empty catalog with no special namespace registered, no root tag and no flavor.  */
    fun mkSimple(): DublinCoreCatalog {
        return DublinCoreCatalog()
    }

    /**
     * Read a DublinCore catalog from a stream containing either JSON or XML. The method is
     * capable of detecting the used format.
     *
     *
     * The reader is not capable of determining the catalog's flavor.
     *
     *
     * **Implementation note:** In order to detect the format the whole stream is read into memory first. If you
     * know upfront whether JSON or XML is used you may want to choose [DublinCoreJsonFormat.read]
     * or [DublinCoreXmlFormat.read] for performance reasons.
     */
    fun read(`in`: InputStream): DublinCoreCatalog {
        val ser: String
        try {
            ser = IOUtils.toString(`in`, "UTF-8")
        } catch (e: IOException) {
            throw RuntimeException("Unable to read DublinCore from stream", e)
        }

        return if (ser.startsWith("{")) {
            try {
                DublinCoreJsonFormat.read(ser)
            } catch (e: Exception) {
                throw RuntimeException("Unable to read DublinCore catalog, JSON parsing failed.", e)
            }

        } else {
            try {
                DublinCoreXmlFormat.read(ser)
            } catch (e: Exception) {
                throw RuntimeException("Unable to read DublinCore catalog, XML parsing failed.", e)
            }

        }
    }

    private fun mkOpencast(flavor: MediaPackageElementFlavor): DublinCoreCatalog {
        val dc = mkStandard()
        dc.flavor = flavor
        dc.addBindings(XmlNamespaceContext.mk(
                // Opencast property namespace
                XmlNamespaceBinding.mk(OC_PROPERTY_NS_PREFIX, OC_PROPERTY_NS_URI),
                // Opencast root tag
                XmlNamespaceBinding.mk(XMLConstants.DEFAULT_NS_PREFIX, OC_DC_CATALOG_NS_URI)))
        //XMLSchema-instance namespace xsi
        XmlNamespaceBinding.mk(XSI_NS_PREFIX, W3C_XML_SCHEMA_INSTANCE_NS_URI)
        dc.rootTag = OC_DC_CATALOG_ROOT_ELEMENT
        return dc
    }
}
